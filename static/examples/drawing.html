<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=3.0, user-scalable=yes" />
  <meta name="description" content="Professional drawing and PDF annotation tool for tablets and devices" />
  <meta name="theme-color" content="#6366f1" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Drawing Board" />
  <link rel="manifest" href="manifest.json" />
  <title>Ù„ÙˆØ­Ø© Ø§Ù„Ø±Ø³Ù… â€” Mishkah Drawing Board</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: "Inter", "Tajawal", system-ui, sans-serif;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
      touch-action: none;
      background: #0f172a;
    }

    /* Canvas Container - enables scrolling when zoomed */
    .canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      overflow: auto;
      background: #0f172a;
    }

    /* Canvas fills entire screen */
    #drawingCanvas {
      display: block;
      background: white;
      cursor: crosshair;
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
    }

    /* Floating Top Toolbar - minimal and transparent */
    .floating-toolbar {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(15, 23, 42, 0.85);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 8px 12px;
      display: flex;
      gap: 8px;
      align-items: center;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    /* Toolbar buttons - small and compact */
    .toolbar-btn {
      background: rgba(51, 65, 85, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.3);
      color: #f8fafc;
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.8rem;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
    }

    .toolbar-btn:hover,
    .toolbar-btn.active {
      background: #6366f1;
      border-color: #6366f1;
    }

    .toolbar-btn-icon {
      font-size: 1rem;
    }

    /* Side Toggle Buttons - minimal */
    .toggle-btn {
      position: fixed;
      background: rgba(15, 23, 42, 0.85);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(148, 163, 184, 0.3);
      color: #f8fafc;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      z-index: 1000;
      transition: all 0.2s;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .toggle-btn:hover {
      background: #6366f1;
      transform: scale(1.1);
    }

    #toggleTools {
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
    }

    #toggleColors {
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
    }

    /* Floating Panels */
    .floating-panel {
      position: fixed;
      background: rgba(15, 23, 42, 0.95);
      backdrop-filter: blur(15px);
      border-radius: 16px;
      padding: 16px;
      z-index: 999;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(148, 163, 184, 0.2);
      max-height: 80vh;
      overflow-y: auto;
      display: none;
    }

    .floating-panel.show {
      display: block;
      animation: slideIn 0.2s ease-out;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    #toolsPanel {
      left: 10px;
      top: 60px;
      width: 200px;
    }

    #colorsPanel {
      right: 10px;
      top: 60px;
      width: 260px;
    }

    .panel-header {
      color: #818cf8;
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .close-panel {
      background: none;
      border: none;
      color: #f8fafc;
      cursor: pointer;
      font-size: 1.2rem;
      padding: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
    }

    .close-panel:hover {
      background: rgba(239, 68, 68, 0.2);
    }

    /* Tools Grid */
    .tools-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .tool-item {
      background: rgba(51, 65, 85, 0.6);
      border: 2px solid transparent;
      border-radius: 10px;
      padding: 10px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      color: rgba(248, 250, 252, 0.8);
      font-size: 0.7rem;
    }

    .tool-item:hover {
      background: rgba(51, 65, 85, 0.9);
      border-color: #818cf8;
    }

    .tool-item.active {
      background: #6366f1;
      border-color: #6366f1;
      color: white;
    }

    .tool-item-icon {
      font-size: 1.6rem;
    }

    /* Colors Section */
    .color-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
      margin-bottom: 12px;
    }

    .color-swatch {
      width: 100%;
      aspect-ratio: 1;
      border-radius: 8px;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all 0.2s;
    }

    .color-swatch:hover {
      transform: scale(1.1);
    }

    .color-swatch.active {
      border-color: white;
      box-shadow: 0 0 0 2px #6366f1;
    }

    .custom-color-wrapper {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }

    .custom-color-input {
      flex: 1;
      height: 40px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 8px;
      cursor: pointer;
      background: transparent;
    }

    /* Brush Size */
    .size-section {
      margin-bottom: 12px;
    }

    .size-label {
      color: #818cf8;
      font-size: 0.8rem;
      margin-bottom: 6px;
      display: block;
    }

    .size-slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(51, 65, 85, 0.6);
      -webkit-appearance: none;
      appearance: none;
      outline: none;
      margin-bottom: 8px;
    }

    .size-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #6366f1;
      cursor: pointer;
    }

    .size-slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #6366f1;
      cursor: pointer;
      border: none;
    }

    .size-preview {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 50px;
      background: white;
      border-radius: 8px;
    }

    .size-preview-dot {
      background: currentColor;
      border-radius: 50%;
      transition: all 0.2s;
    }

    /* Shapes Grid */
    .shapes-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    .shape-btn {
      aspect-ratio: 1;
      background: rgba(51, 65, 85, 0.6);
      border: 2px solid transparent;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
      transition: all 0.2s;
    }

    .shape-btn:hover {
      background: rgba(51, 65, 85, 0.9);
      border-color: #818cf8;
    }

    /* Bottom Status Bar - minimal */
    .status-bar {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(15, 23, 42, 0.75);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 6px 16px;
      font-size: 0.75rem;
      color: rgba(248, 250, 252, 0.8);
      z-index: 1000;
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .status-divider {
      width: 1px;
      height: 12px;
      background: rgba(148, 163, 184, 0.3);
    }

    /* Modals */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      align-items: center;
      justify-content: center;
      z-index: 2000;
      backdrop-filter: blur(5px);
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: rgba(15, 23, 42, 0.98);
      border-radius: 16px;
      padding: 24px;
      max-width: 500px;
      width: 90%;
      border: 1px solid rgba(148, 163, 184, 0.2);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      max-height: 90vh;
      overflow-y: auto;
    }

    .modal-header {
      font-size: 1.3rem;
      font-weight: 700;
      margin-bottom: 20px;
      color: #818cf8;
    }

    .form-group {
      margin-bottom: 16px;
    }

    .form-label {
      display: block;
      margin-bottom: 6px;
      font-size: 0.9rem;
      color: rgba(248, 250, 252, 0.8);
    }

    .form-input {
      width: 100%;
      background: rgba(30, 41, 59, 0.8);
      border: 1px solid rgba(148, 163, 184, 0.3);
      color: #f8fafc;
      padding: 10px;
      border-radius: 8px;
      font-size: 0.9rem;
    }

    .form-input:focus {
      outline: none;
      border-color: #6366f1;
    }

    .modal-actions {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }

    .btn {
      flex: 1;
      padding: 10px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      border: none;
      transition: all 0.2s;
    }

    .btn-primary {
      background: #6366f1;
      color: white;
    }

    .btn-primary:hover {
      background: #5558e3;
    }

    .btn-secondary {
      background: rgba(51, 65, 85, 0.6);
      color: #f8fafc;
    }

    .btn-secondary:hover {
      background: rgba(51, 65, 85, 0.9);
    }

    /* Files List */
    .files-list {
      max-height: 400px;
      overflow-y: auto;
      margin-bottom: 16px;
    }

    .file-item {
      background: rgba(30, 41, 59, 0.6);
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border: 1px solid rgba(148, 163, 184, 0.2);
      cursor: pointer;
      transition: all 0.2s;
    }

    .file-item:hover {
      border-color: #818cf8;
      background: rgba(30, 41, 59, 0.8);
    }

    .file-info {
      flex: 1;
    }

    .file-name {
      font-weight: 600;
      margin-bottom: 4px;
      color: #f8fafc;
    }

    .file-meta {
      font-size: 0.75rem;
      color: rgba(148, 163, 184, 0.8);
    }

    .file-actions {
      display: flex;
      gap: 6px;
    }

    .btn-small {
      padding: 4px 8px;
      font-size: 0.8rem;
      background: rgba(239, 68, 68, 0.2);
      border: 1px solid rgba(239, 68, 68, 0.3);
      color: #f8fafc;
      border-radius: 6px;
      cursor: pointer;
    }

    .btn-small:hover {
      background: rgba(239, 68, 68, 0.4);
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(30, 41, 59, 0.5);
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(99, 102, 241, 0.5);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #6366f1;
    }

    #imageUpload {
      display: none;
    }

    .section-divider {
      height: 1px;
      background: rgba(148, 163, 184, 0.2);
      margin: 12px 0;
    }

    /* PDF Navigation */
    .pdf-navigation {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(15, 23, 42, 0.85);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 8px 12px;
      gap: 8px;
      align-items: center;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .pdf-navigation.active {
      display: flex;
    }

    .pdf-nav-btn {
      background: rgba(99, 102, 241, 0.2);
      border: 1px solid rgba(99, 102, 241, 0.4);
      color: #f8fafc;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.2s;
    }

    .pdf-nav-btn:hover:not(:disabled) {
      background: rgba(99, 102, 241, 0.4);
      border-color: #6366f1;
    }

    .pdf-nav-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .pdf-page-info {
      color: #f8fafc;
      font-size: 0.9rem;
      padding: 0 8px;
    }

    /* Page Selector */
    .page-selector {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 10px;
      max-height: 400px;
      overflow-y: auto;
      margin: 20px 0;
    }

    .page-item {
      background: rgba(30, 41, 59, 0.6);
      border: 2px solid rgba(148, 163, 184, 0.3);
      border-radius: 8px;
      padding: 8px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .page-item:hover {
      border-color: #6366f1;
    }

    .page-item.selected {
      border-color: #10b981;
      background: rgba(16, 185, 129, 0.2);
    }

    .page-preview {
      width: 100%;
      height: 120px;
      background: white;
      border-radius: 4px;
      margin-bottom: 6px;
    }

    .page-label {
      color: #f8fafc;
      font-size: 0.85rem;
    }

    /* Install Prompt */
    .install-prompt {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      color: white;
      padding: 16px 24px;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(99, 102, 241, 0.4);
      display: none;
      align-items: center;
      gap: 12px;
      z-index: 10000;
      max-width: 90%;
      animation: slideUp 0.3s ease-out;
    }

    .install-prompt.active {
      display: flex;
    }

    @keyframes slideUp {
      from {
        transform: translateX(-50%) translateY(100px);
        opacity: 0;
      }
      to {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
      }
    }

    .install-prompt-icon {
      font-size: 2rem;
    }

    .install-prompt-content {
      flex: 1;
    }

    .install-prompt-title {
      font-weight: 700;
      font-size: 1rem;
      margin-bottom: 4px;
    }

    .install-prompt-text {
      font-size: 0.85rem;
      opacity: 0.9;
    }

    .install-prompt-actions {
      display: flex;
      gap: 8px;
    }

    .install-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      transition: all 0.2s;
    }

    .install-btn-primary {
      background: white;
      color: #6366f1;
    }

    .install-btn-primary:hover {
      transform: scale(1.05);
    }

    .install-btn-secondary {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }

    .install-btn-secondary:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    /* Language Switcher */
    /* Reload Button */
    .reload-btn {
      background: rgba(15, 23, 42, 0.85);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(148, 163, 184, 0.3);
      color: #f8fafc;
      padding: 8px 14px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1.1rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .reload-btn:hover {
      background: #6366f1;
      border-color: #6366f1;
    }

    .reload-btn:hover span:first-child {
      display: inline-block;
      animation: rotate 0.6s ease-in-out;
    }

    @keyframes rotate {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }

    .reload-text {
      font-size: 0.75rem;
      font-weight: 600;
    }

    .lang-switcher {
      position: fixed;
      top: 70px;
      right: 10px;
      background: rgba(15, 23, 42, 0.85);
      backdrop-filter: blur(10px);
      border-radius: 8px;
      padding: 4px;
      display: flex;
      gap: 4px;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .lang-btn {
      background: transparent;
      border: 1px solid rgba(148, 163, 184, 0.3);
      color: #f8fafc;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.2s;
      font-weight: 600;
    }

    .lang-btn.active {
      background: #6366f1;
      border-color: #6366f1;
    }

    .lang-btn:hover:not(.active) {
      background: rgba(99, 102, 241, 0.2);
      border-color: #6366f1;
    }

    /* Loading Overlay */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(15, 23, 42, 0.95);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 100000;
      flex-direction: column;
      gap: 20px;
    }

    .loading-overlay.active {
      display: flex;
    }

    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(99, 102, 241, 0.3);
      border-top-color: #6366f1;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-text {
      color: #f8fafc;
      font-size: 1.1rem;
      font-weight: 600;
    }

    .loading-progress {
      color: rgba(248, 250, 252, 0.7);
      font-size: 0.9rem;
    }

    /* Page Range Input */
    .page-range-input {
      background: rgba(30, 41, 59, 0.8);
      border: 1px solid rgba(148, 163, 184, 0.3);
      color: #f8fafc;
      padding: 10px;
      border-radius: 8px;
      width: 100%;
      font-size: 0.9rem;
      margin-bottom: 10px;
    }

    .page-range-input:focus {
      outline: none;
      border-color: #6366f1;
    }

    .page-range-help {
      color: rgba(248, 250, 252, 0.6);
      font-size: 0.8rem;
      margin-bottom: 10px;
    }

    .page-selector-header {
      display: flex;
      gap: 8px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }

    .page-selector-btn {
      padding: 6px 12px;
      background: rgba(99, 102, 241, 0.2);
      border: 1px solid rgba(99, 102, 241, 0.4);
      color: #f8fafc;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.2s;
    }

    .page-selector-btn:hover {
      background: rgba(99, 102, 241, 0.4);
      border-color: #6366f1;
    }

    /* Hide All UI Mode - Keep PDF navigation and hide zoom controls */
    body.zen-mode .floating-toolbar,
    body.zen-mode .pdf-navigation,
    body.zen-mode .toggle-btn,
    body.zen-mode .lang-switcher,
    body.zen-mode .reload-btn,
    body.zen-mode .status-bar,
    body.zen-mode .install-prompt,
    body.zen-mode .zoom-controls {
      display: none !important;
    }

    .zen-mode-toggle {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(15, 23, 42, 0.85);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(148, 163, 184, 0.3);
      color: #f8fafc;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.85rem;
      z-index: 10001;
      transition: all 0.2s;
    }

    body.zen-mode .zen-mode-toggle {
      background: #6366f1;
      border-color: #6366f1;
    }

    .zen-mode-toggle:hover {
      background: rgba(99, 102, 241, 0.4);
      border-color: #6366f1;
    }

    /* Zoom Controls */
    .zoom-controls {
      position: fixed;
      bottom: 80px;
      right: 10px;
      background: rgba(15, 23, 42, 0.85);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .zoom-btn {
      background: rgba(99, 102, 241, 0.2);
      border: 1px solid rgba(99, 102, 241, 0.4);
      color: #f8fafc;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.2s;
    }

    .zoom-btn:hover {
      background: rgba(99, 102, 241, 0.4);
      border-color: #6366f1;
    }

    .zoom-level {
      color: #f8fafc;
      font-size: 0.85rem;
      text-align: center;
      padding: 4px;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    // Configure PDF.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
  </script>
</head>
<body>
  <!-- Canvas Container - enables scrolling when zoomed -->
  <div id="canvasContainer" class="canvas-container">
    <!-- Main Canvas - fills entire screen -->
    <canvas id="drawingCanvas"></canvas>
  </div>

  <!-- Hard Reload Button -->


  <!-- Language Switcher -->
  <div class="lang-switcher">
    <button class="lang-btn active" data-lang="ar" onclick="app.switchLanguage('ar')">Ø¹</button>
    <button class="lang-btn" data-lang="en" onclick="app.switchLanguage('en')">EN</button>
  </div>

  <!-- Install Prompt -->
  <div class="install-prompt" id="installPrompt">
    <div class="install-prompt-icon">ğŸ“²</div>
    <div class="install-prompt-content">
      <div class="install-prompt-title" data-i18n="install_title">Ø«Ø¨Ù‘Øª Ø§Ù„ØªØ·Ø¨ÙŠÙ‚</div>
      <div class="install-prompt-text" data-i18n="install_text">Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªØ¬Ø±Ø¨Ø© Ø£ÙØ¶Ù„ ÙˆØ§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¨Ø¯ÙˆÙ† Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª</div>
    </div>
    <div class="install-prompt-actions">
      <button class="install-btn install-btn-primary" onclick="app.installApp()" data-i18n="install_btn">ØªØ«Ø¨ÙŠØª</button>
      <button class="install-btn install-btn-secondary" onclick="app.dismissInstall()" data-i18n="later_btn">Ù„Ø§Ø­Ù‚Ø§Ù‹</button>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
    <div class="loading-text" data-i18n="loading">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...</div>
    <div class="loading-progress" id="loadingProgress"></div>
  </div>

  <!-- Zen Mode Toggle -->
  <button class="zen-mode-toggle" onclick="app.toggleZenMode()" data-i18n="zen_mode">ğŸ“–</button>

  <!-- Zoom Controls -->
  <div class="zoom-controls">
    <button class="zoom-btn" onclick="app.zoomIn()">+</button>
    <div class="zoom-level" id="zoomLevel">100%</div>
    <button class="zoom-btn" onclick="app.zoomOut()">âˆ’</button>
    <button class="zoom-btn" onclick="app.resetZoom()">âŸ²</button>
  </div>

  <!-- Floating Top Toolbar -->
  <div class="floating-toolbar">
    <button class="reload-btn toolbar-btn" onclick="app.hardReload()" title="ØªØ­Ø¯ÙŠØ« Ù‚ÙˆÙŠ - Hard Reload">
      <span>ğŸ”„</span>
      <span class="reload-text" data-i18n="reload">ØªØ­Ø¯ÙŠØ«</span>
    </button>
    <button class="toolbar-btn" onclick="app.undo()">
      <span class="toolbar-btn-icon">â†¶</span>
      <span data-i18n="undo" style='display:none'>ØªØ±Ø§Ø¬Ø¹</span>
    </button>
    <button class="toolbar-btn" onclick="app.redo()">
      <span class="toolbar-btn-icon">â†·</span>
      <span data-i18n="redo" style='display:none'>Ø¥Ø¹Ø§Ø¯Ø©</span>
    </button>
    <button class="toolbar-btn" onclick="app.clearCanvas()">
      <span class="toolbar-btn-icon">ğŸ—‘ï¸</span>
    </button>
    <div style="width: 1px; height: 20px; background: rgba(148, 163, 184, 0.3);"></div>
    <button class="toolbar-btn" onclick="app.openSaveModal()">
      <span class="toolbar-btn-icon">ğŸ’¾</span>
      <span data-i18n="save">Ø­ÙØ¸</span>
    </button>
    <button class="toolbar-btn" onclick="app.openLoadModal()">
      <span class="toolbar-btn-icon">ğŸ“</span>
    </button>
    <button class="toolbar-btn" onclick="app.openExportModal()">
      <span class="toolbar-btn-icon">ğŸ“¤</span>
    </button>
    <div style="width: 1px; height: 20px; background: rgba(148, 163, 184, 0.3);"></div>
    <button class="toolbar-btn" onclick="document.getElementById('pdfUpload').click()">
      <span class="toolbar-btn-icon">ğŸ“„</span>
      <span>PDF</span>
    </button>
  </div>

  <!-- PDF Navigation Bar -->
  <div class="pdf-navigation" id="pdfNavigation">
    <button class="pdf-nav-btn" id="prevPageBtn" onclick="app.previousPage()">
      <span>â†</span> <span data-i18n="previous">Ø§Ù„Ø³Ø§Ø¨Ù‚</span>
    </button>
    <span class="pdf-page-info" id="pageInfo">ØµÙØ­Ø© 1 Ù…Ù† 1</span>
    <button class="pdf-nav-btn" id="nextPageBtn" onclick="app.nextPage()">
      <span data-i18n="next">Ø§Ù„ØªØ§Ù„ÙŠ</span> <span>â†’</span>
    </button>
  </div>

  <!-- Toggle Buttons -->
  <button class="toggle-btn" id="toggleTools" onclick="app.togglePanel('tools')">ğŸ› ï¸</button>
  <button class="toggle-btn" id="toggleColors" onclick="app.togglePanel('colors')">ğŸ¨</button>

  <!-- Tools Panel -->
  <div class="floating-panel" id="toolsPanel">
    <div class="panel-header">
      Ø§Ù„Ø£Ø¯ÙˆØ§Øª
      <button class="close-panel" onclick="app.closePanel('tools')">Ã—</button>
    </div>
    <div class="tools-grid">
      <div class="tool-item active" onclick="app.setTool('pen')" data-tool="pen">
        <span class="tool-item-icon">âœï¸</span>
        <span>Ù‚Ù„Ù…</span>
      </div>
      <div class="tool-item" onclick="app.setTool('brush')" data-tool="brush">
        <span class="tool-item-icon">ğŸ–Œï¸</span>
        <span>ÙØ±Ø´Ø§Ø©</span>
      </div>
      <div class="tool-item" onclick="app.setTool('eraser')" data-tool="eraser">
        <span class="tool-item-icon">ğŸ§¹</span>
        <span>Ù…Ù…Ø­Ø§Ø©</span>
      </div>
      <div class="tool-item" onclick="app.setTool('line')" data-tool="line">
        <span class="tool-item-icon">ğŸ“</span>
        <span>Ø®Ø·</span>
      </div>
      <div class="tool-item" onclick="app.setTool('rectangle')" data-tool="rectangle">
        <span class="tool-item-icon">â–­</span>
        <span>Ù…Ø±Ø¨Ø¹</span>
      </div>
      <div class="tool-item" onclick="app.setTool('circle')" data-tool="circle">
        <span class="tool-item-icon">â­•</span>
        <span>Ø¯Ø§Ø¦Ø±Ø©</span>
      </div>
      <div class="tool-item" onclick="app.setTool('arrow')" data-tool="arrow">
        <span class="tool-item-icon">â¡ï¸</span>
        <span>Ø³Ù‡Ù…</span>
      </div>
      <div class="tool-item" onclick="app.setTool('text')" data-tool="text">
        <span class="tool-item-icon">ğŸ“</span>
        <span data-i18n="text">Ù†Øµ</span>
      </div>
      <div class="tool-item" onclick="app.setTool('pan')" data-tool="pan">
        <span class="tool-item-icon">âœ‹</span>
        <span data-i18n="pan">ØªØ­Ø±ÙŠÙƒ/ØªÙƒØ¨ÙŠØ±</span>
      </div>
    </div>
    <div class="section-divider"></div>
    <div class="panel-header" style="margin-top: 12px;">Ø£Ø´ÙƒØ§Ù„ Ø¬Ø§Ù‡Ø²Ø©</div>
    <div class="shapes-grid">
      <button class="shape-btn" onclick="app.insertShape('star')">â­</button>
      <button class="shape-btn" onclick="app.insertShape('heart')">â¤ï¸</button>
      <button class="shape-btn" onclick="app.insertShape('triangle')">ğŸ”º</button>
      <button class="shape-btn" onclick="app.insertShape('hexagon')">â¬¡</button>
      <button class="shape-btn" onclick="app.insertShape('pentagon')">â¬Ÿ</button>
      <button class="shape-btn" onclick="app.insertShape('diamond')">ğŸ’</button>
    </div>
    <div class="section-divider"></div>
    <button class="toolbar-btn" style="width: 100%; justify-content: center; margin-top: 8px;" onclick="app.importImage()">
      <span class="toolbar-btn-icon">ğŸ–¼ï¸</span>
      <span>Ø§Ø³ØªÙŠØ±Ø§Ø¯ ØµÙˆØ±Ø©</span>
    </button>
  </div>

  <!-- Colors Panel -->
  <div class="floating-panel" id="colorsPanel">
    <div class="panel-header">
      Ø§Ù„Ø£Ù„ÙˆØ§Ù† ÙˆØ§Ù„Ø­Ø¬Ù…
      <button class="close-panel" onclick="app.closePanel('colors')">Ã—</button>
    </div>
    <div class="color-grid" id="colorGrid"></div>
    <div class="custom-color-wrapper">
      <input type="color" class="custom-color-input" id="customColor" value="#000000" />
    </div>
    <div class="section-divider"></div>
    <div class="size-section">
      <label class="size-label">Ø­Ø¬Ù… Ø§Ù„ÙØ±Ø´Ø§Ø©: <span id="brushSizeLabel">3</span>px</label>
      <input type="range" class="size-slider" id="brushSize" min="1" max="50" value="3" />
      <div class="size-preview">
        <div id="sizePreviewDot" class="size-preview-dot"></div>
      </div>
    </div>
  </div>

  <!-- Status Bar -->
  <div class="status-bar">
    <span>Ø§Ù„Ø£Ø¯Ø§Ø©: <span id="toolStatus">pen</span></span>
    <span class="status-divider"></span>
    <span id="historyInfo">1 / 1</span>
  </div>

  <!-- Save Modal -->
  <div class="modal" id="saveModal">
    <div class="modal-content">
      <h2 class="modal-header">ğŸ’¾ Ø­ÙØ¸ Ø§Ù„Ø±Ø³Ù…Ø©</h2>
      <div class="form-group">
        <label class="form-label">Ø§Ø³Ù… Ø§Ù„Ø±Ø³Ù…Ø©</label>
        <input type="text" class="form-input" id="saveName" placeholder="Ø£Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„Ø±Ø³Ù…Ø©..." />
      </div>
      <div class="form-group">
        <label class="form-label">Ø§Ù„Ù…Ø¬Ù„Ø¯ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)</label>
        <input type="text" class="form-input" id="saveFolder" placeholder="Ù…Ø«Ø§Ù„: Ø±Ø³ÙˆÙ…Ø§ØªÙŠ" />
      </div>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="app.closeSaveModal()">Ø¥Ù„ØºØ§Ø¡</button>
        <button class="btn btn-primary" onclick="app.saveDrawing()">Ø­ÙØ¸</button>
      </div>
    </div>
  </div>

  <!-- Load Modal -->
  <div class="modal" id="loadModal">
    <div class="modal-content">
      <h2 class="modal-header">ğŸ“ ÙØªØ­ Ø±Ø³Ù…Ø©</h2>
      <div class="files-list" id="filesList"></div>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="app.closeLoadModal()">Ø¥ØºÙ„Ø§Ù‚</button>
      </div>
    </div>
  </div>

  <!-- Export Modal -->
  <div class="modal" id="exportModal">
    <div class="modal-content">
      <h2 class="modal-header">ğŸ“¤ ØªØµØ¯ÙŠØ± Ø§Ù„Ø±Ø³Ù…Ø©</h2>
      <div style="display: flex; flex-direction: column; gap: 10px;">
        <button class="btn btn-primary" onclick="app.exportAsPNG()">ØªØµØ¯ÙŠØ± ÙƒÙ€ PNG</button>
        <button class="btn btn-primary" onclick="app.exportAsJPG()">ØªØµØ¯ÙŠØ± ÙƒÙ€ JPG</button>
        <button class="btn btn-primary" onclick="app.exportAsPDF()">ØªØµØ¯ÙŠØ± ÙƒÙ€ PDF</button>
        <button class="btn btn-secondary" onclick="app.closeExportModal()">Ø¥Ù„ØºØ§Ø¡</button>
      </div>
    </div>
  </div>

  <!-- PDF Page Selector Modal -->
  <div class="modal" id="pdfPageModal">
    <div class="modal-content" style="max-width: 800px;">
      <h2 class="modal-header" data-i18n="select_pdf_pages">ğŸ“„ Ø§Ø®ØªÙŠØ§Ø± ØµÙØ­Ø§Øª PDF</h2>

      <!-- Page Range Input -->
      <input
        type="text"
        class="page-range-input"
        id="pageRangeInput"
        placeholder="1-10, 15, 20-25"
        data-i18n-placeholder="page_range_placeholder"
      />
      <div class="page-range-help" data-i18n="page_range_help">
        Ù…Ø«Ø§Ù„: 1-10 (Ù…Ù† 1 Ø¥Ù„Ù‰ 10)ØŒ 15,20,25 (ØµÙØ­Ø§Øª Ù…Ø­Ø¯Ø¯Ø©)ØŒ Ø£Ùˆ Ø§Ù„ÙƒÙ„
      </div>

      <!-- Quick Actions -->
      <div class="page-selector-header">
        <button class="page-selector-btn" onclick="app.selectAllPages()" data-i18n="select_all">ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙƒÙ„</button>
        <button class="page-selector-btn" onclick="app.deselectAllPages()" data-i18n="deselect_all">Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ÙƒÙ„</button>
        <button class="page-selector-btn" onclick="app.applyPageRange()" data-i18n="apply_range">ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù†Ø·Ø§Ù‚</button>
        <button class="page-selector-btn" onclick="app.previewRange()" data-i18n="preview_range">Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù†Ø·Ø§Ù‚</button>
      </div>

      <p style="color: rgba(248, 250, 252, 0.7); margin-bottom: 10px; font-size: 0.9rem;" data-i18n="select_pages_text">
        Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„ØµÙØ­Ø§Øª Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø§Ø³ØªÙŠØ±Ø§Ø¯Ù‡Ø§ (ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø®ØªÙŠØ§Ø± Ø¹Ø¯Ø© ØµÙØ­Ø§Øª)
      </p>
      <div class="page-selector" id="pdfPageSelector"></div>
      <div class="modal-actions">
        <button class="btn btn-primary" onclick="app.importSelectedPages()" data-i18n="import_selected">Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„ØµÙØ­Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©</button>
        <button class="btn btn-secondary" onclick="app.closePdfModal()" data-i18n="cancel">Ø¥Ù„ØºØ§Ø¡</button>
      </div>
    </div>
  </div>

  <!-- Export Pages Selector Modal -->
  <div class="modal" id="exportPagesModal">
    <div class="modal-content" style="max-width: 800px;">
      <h2 class="modal-header">ğŸ“¤ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ØµÙØ­Ø§Øª Ù„Ù„ØªØµØ¯ÙŠØ±</h2>

      <!-- Page Range Input -->
      <input
        type="text"
        class="page-range-input"
        id="exportPageRangeInput"
        placeholder="1-10, 15, 20-25"
        data-i18n-placeholder="page_range_placeholder"
      />
      <div class="page-range-help" data-i18n="page_range_help">
        Ù…Ø«Ø§Ù„: 1-10 (Ù…Ù† 1 Ø¥Ù„Ù‰ 10)ØŒ 15,20,25 (ØµÙØ­Ø§Øª Ù…Ø­Ø¯Ø¯Ø©)ØŒ Ø£Ùˆ Ø§Ù„ÙƒÙ„
      </div>

      <!-- Quick Actions -->
      <div class="page-selector-header">
        <button class="page-selector-btn" onclick="app.selectAllExportPages()" data-i18n="select_all">ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙƒÙ„</button>
        <button class="page-selector-btn" onclick="app.deselectAllExportPages()" data-i18n="deselect_all">Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ÙƒÙ„</button>
        <button class="page-selector-btn" onclick="app.applyExportPageRange()" data-i18n="apply_range">ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù†Ø·Ø§Ù‚</button>
      </div>

      <p style="color: rgba(248, 250, 252, 0.7); margin-bottom: 10px; font-size: 0.9rem;">
        Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„ØµÙØ­Ø§Øª Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ ØªØµØ¯ÙŠØ±Ù‡Ø§ (ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø®ØªÙŠØ§Ø± Ø¹Ø¯Ø© ØµÙØ­Ø§Øª)
      </p>
      <div class="page-selector" id="exportPageSelector"></div>
      <div class="modal-actions">
        <button class="btn btn-primary" onclick="app.confirmExportPages()">ØªØµØ¯ÙŠØ± Ø§Ù„ØµÙØ­Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©</button>
        <button class="btn btn-secondary" onclick="app.closeExportPagesModal()">Ø¥Ù„ØºØ§Ø¡</button>
      </div>
    </div>
  </div>

  <!-- Hidden file inputs -->
  <input type="file" id="imageUpload" accept="image/*" />
  <input type="file" id="pdfUpload" accept="application/pdf" style="display: none;" />

  <!-- jsPDF for PDF export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <script>
    // Drawing Application
    const app = {
      currentTool: 'pen',
      currentColor: '#000000',
      brushSize: 3,
      isDrawing: false,
      startX: 0,
      startY: 0,
      history: [],
      historyIndex: -1,
      lastSaved: null,

      // PDF-related properties
      pdfDoc: null,
      pdfPages: [],
      currentPageIndex: 0,
      selectedPdfPages: new Set(),
      pdfMode: false,
      pageAnnotations: {}, // Store annotations for each page

      // PWA properties
      currentLang: 'ar',
      deferredPrompt: null,
      db: null,

      // Zoom and UI properties
      zoomLevel: 1,
      zenMode: false,
      pinchStartDistance: 0,
      isPinching: false,

      colors: [
        '#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00',
        '#FF00FF', '#00FFFF', '#FFA500', '#800080', '#008000', '#800000',
        '#808080', '#C0C0C0', '#FFB6C1', '#87CEEB', '#90EE90', '#DDA0DD'
      ],

      // Translations
      translations: {
        ar: {
          // Install prompt
          install_title: 'Ø«Ø¨Ù‘Øª Ø§Ù„ØªØ·Ø¨ÙŠÙ‚',
          install_text: 'Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªØ¬Ø±Ø¨Ø© Ø£ÙØ¶Ù„ ÙˆØ§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¨Ø¯ÙˆÙ† Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª',
          install_btn: 'ØªØ«Ø¨ÙŠØª',
          later_btn: 'Ù„Ø§Ø­Ù‚Ø§Ù‹',

          // Toolbar
          undo: 'ØªØ±Ø§Ø¬Ø¹',
          redo: 'Ø¥Ø¹Ø§Ø¯Ø©',
          save: 'Ø­ÙØ¸',

          // PDF Navigation
          previous: 'Ø§Ù„Ø³Ø§Ø¨Ù‚',
          next: 'Ø§Ù„ØªØ§Ù„ÙŠ',
          page: 'ØµÙØ­Ø©',
          of: 'Ù…Ù†',

          // Tools
          pen: 'Ù‚Ù„Ù…',
          brush: 'ÙØ±Ø´Ø§Ø©',
          eraser: 'Ù…Ù…Ø­Ø§Ø©',
          line: 'Ø®Ø·',
          rectangle: 'Ù…Ø±Ø¨Ø¹',
          circle: 'Ø¯Ø§Ø¦Ø±Ø©',
          arrow: 'Ø³Ù‡Ù…',
          text: 'Ù†Øµ',
          pan: 'ØªØ­Ø±ÙŠÙƒ/ØªÙƒØ¨ÙŠØ±',

          // Modals
          save_drawing: 'Ø­ÙØ¸ Ø§Ù„Ø±Ø³Ù…Ø©',
          drawing_name: 'Ø§Ø³Ù… Ø§Ù„Ø±Ø³Ù…Ø©',
          cancel: 'Ø¥Ù„ØºØ§Ø¡',
          open_drawing: 'ÙØªØ­ Ø±Ø³Ù…Ø©',
          close: 'Ø¥ØºÙ„Ø§Ù‚',
          export_drawing: 'ØªØµØ¯ÙŠØ± Ø§Ù„Ø±Ø³Ù…Ø©',
          export_png: 'ØªØµØ¯ÙŠØ± ÙƒÙ€ PNG',
          export_jpg: 'ØªØµØ¯ÙŠØ± ÙƒÙ€ JPG',
          export_pdf: 'ØªØµØ¯ÙŠØ± ÙƒÙ€ PDF',

          // PDF
          select_pdf_pages: 'Ø§Ø®ØªÙŠØ§Ø± ØµÙØ­Ø§Øª PDF',
          select_pages_text: 'Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„ØµÙØ­Ø§Øª Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø§Ø³ØªÙŠØ±Ø§Ø¯Ù‡Ø§ (ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø®ØªÙŠØ§Ø± Ø¹Ø¯Ø© ØµÙØ­Ø§Øª)',
          import_selected: 'Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„ØµÙØ­Ø§Øª Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©',

          // Messages
          clear_confirm: 'Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ù…Ø³Ø­ Ø§Ù„Ù„ÙˆØ­Ø©ØŸ',
          delete_confirm: 'Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ù‡ Ø§Ù„Ø±Ø³Ù…Ø©ØŸ',
          select_one_page: 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± ØµÙØ­Ø© ÙˆØ§Ø­Ø¯Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„',
          pdf_load_error: 'Ø®Ø·Ø£ ÙÙŠ ÙØªØ­ Ù…Ù„Ù PDF',
          page_load_error: 'Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©',
          enter_name: 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ù„Ù„Ø±Ø³Ù…Ø©',
          saved_success: 'ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø¨Ù†Ø¬Ø§Ø­!',

          // New features
          loading: 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...',
          zen_mode: 'ğŸ“–',
          select_all: 'ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙƒÙ„',
          deselect_all: 'Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ÙƒÙ„',
          apply_range: 'ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù†Ø·Ø§Ù‚',
          preview_range: 'Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù†Ø·Ø§Ù‚',
          page_range_placeholder: '1-10, 15, 20-25',
          page_range_help: 'Ù…Ø«Ø§Ù„: 1-10 (Ù…Ù† 1 Ø¥Ù„Ù‰ 10)ØŒ 15,20,25 (ØµÙØ­Ø§Øª Ù…Ø­Ø¯Ø¯Ø©)ØŒ Ø£Ùˆ Ø§Ù„ÙƒÙ„',
          loading_pages: 'Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø§Øª...',
          page_x_of_y: 'ØµÙØ­Ø© {0} Ù…Ù† {1}',
          reload: 'ØªØ­Ø¯ÙŠØ«'
        },
        en: {
          // Install prompt
          install_title: 'Install App',
          install_text: 'For a better experience and offline usage',
          install_btn: 'Install',
          later_btn: 'Later',

          // Toolbar
          undo: 'Undo',
          redo: 'Redo',
          save: 'Save',

          // PDF Navigation
          previous: 'Previous',
          next: 'Next',
          page: 'Page',
          of: 'of',

          // Tools
          pen: 'Pen',
          brush: 'Brush',
          eraser: 'Eraser',
          line: 'Line',
          rectangle: 'Rectangle',
          circle: 'Circle',
          arrow: 'Arrow',
          text: 'Text',
          pan: 'Pan/Zoom',

          // Modals
          save_drawing: 'Save Drawing',
          drawing_name: 'Drawing Name',
          cancel: 'Cancel',
          open_drawing: 'Open Drawing',
          close: 'Close',
          export_drawing: 'Export Drawing',
          export_png: 'Export as PNG',
          export_jpg: 'Export as JPG',
          export_pdf: 'Export as PDF',

          // PDF
          select_pdf_pages: 'Select PDF Pages',
          select_pages_text: 'Click on the pages you want to import (you can select multiple pages)',
          import_selected: 'Import Selected Pages',

          // Messages
          clear_confirm: 'Are you sure you want to clear the canvas?',
          delete_confirm: 'Are you sure you want to delete this drawing?',
          select_one_page: 'Please select at least one page',
          pdf_load_error: 'Error opening PDF file',
          page_load_error: 'Error loading page',
          enter_name: 'Please enter a name for the drawing',
          saved_success: 'Saved successfully!',

          // New features
          loading: 'Loading...',
          zen_mode: 'ğŸ“–',
          select_all: 'Select All',
          deselect_all: 'Deselect All',
          apply_range: 'Apply Range',
          preview_range: 'Preview Range',
          page_range_placeholder: '1-10, 15, 20-25',
          page_range_help: 'Example: 1-10 (pages 1 to 10), 15,20,25 (specific pages), or all',
          loading_pages: 'Loading pages...',
          page_x_of_y: 'Page {0} of {1}',
          reload: 'Reload'
        }
      },

      async init() {
        this.canvas = document.getElementById('drawingCanvas');
        this.ctx = this.canvas.getContext('2d');

        // Set canvas size to window size
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());

        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';

        // Initialize PWA features
        await this.initPWA();

        // Load saved language
        this.currentLang = localStorage.getItem('drawing_lang') || 'ar';
        this.applyLanguage();

        this.saveState();
        this.setupEventListeners();
        this.renderColors();
        this.updateUI();

        console.log('ğŸ¨ Drawing board ready!');
      },

      // PWA Initialization
      async initPWA() {
        // Register Service Worker
        if ('serviceWorker' in navigator) {
          try {
            const registration = await navigator.serviceWorker.register('./sw.js');
            console.log('âœ… Service Worker registered:', registration.scope);
          } catch (error) {
            console.error('âŒ Service Worker registration failed:', error);
          }
        }

        // Initialize IndexedDB
        await this.initDB();

        // Setup install prompt
        window.addEventListener('beforeinstallprompt', (e) => {
          e.preventDefault();
          this.deferredPrompt = e;

          // Check if user hasn't dismissed the prompt before
          const dismissed = localStorage.getItem('install_dismissed');
          const installed = window.matchMedia('(display-mode: standalone)').matches;

          if (!dismissed && !installed) {
            // Show install prompt after 3 seconds
            setTimeout(() => {
              document.getElementById('installPrompt').classList.add('active');
            }, 3000);
          }
        });

        // Detect if already installed
        window.addEventListener('appinstalled', () => {
          console.log('âœ… App installed successfully!');
          this.deferredPrompt = null;
          document.getElementById('installPrompt').classList.remove('active');
        });
      },

      // IndexedDB Initialization
      async initDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open('MishkahDrawingDB', 1);

          request.onerror = () => reject(request.error);
          request.onsuccess = () => {
            this.db = request.result;
            console.log('âœ… IndexedDB initialized');
            resolve();
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;

            // Create object stores
            if (!db.objectStoreNames.contains('drawings')) {
              const drawingStore = db.createObjectStore('drawings', { keyPath: 'id', autoIncrement: true });
              drawingStore.createIndex('name', 'name', { unique: false });
              drawingStore.createIndex('timestamp', 'timestamp', { unique: false });
            }

            if (!db.objectStoreNames.contains('history')) {
              const historyStore = db.createObjectStore('history', { keyPath: 'id', autoIncrement: true });
              historyStore.createIndex('timestamp', 'timestamp', { unique: false });
            }
          };
        });
      },

      resizeCanvas() {
        const oldData = this.canvas.toDataURL();
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;

        // Restore content after resize
        if (oldData) {
          const img = new Image();
          img.onload = () => {
            this.ctx.drawImage(img, 0, 0);
          };
          img.src = oldData;
        } else {
          this.ctx.fillStyle = 'white';
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }
      },

      setupEventListeners() {
        this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
        this.canvas.addEventListener('mousemove', (e) => this.draw(e));
        this.canvas.addEventListener('mouseup', (e) => this.stopDrawing(e));
        this.canvas.addEventListener('mouseout', () => this.stopDrawing());

        this.canvas.addEventListener('touchstart', (e) => this.handleTouch(e, 'start'), { passive: false });
        this.canvas.addEventListener('touchmove', (e) => this.handleTouch(e, 'move'), { passive: false });
        this.canvas.addEventListener('touchend', () => this.stopDrawing(), { passive: true });

        document.getElementById('customColor').addEventListener('input', (e) => {
          this.currentColor = e.target.value;
          this.updateUI();
        });

        document.getElementById('brushSize').addEventListener('input', (e) => {
          this.brushSize = parseInt(e.target.value);
          this.updateUI();
        });

        document.getElementById('imageUpload').addEventListener('change', (e) => this.handleImageUpload(e));
        document.getElementById('pdfUpload').addEventListener('change', (e) => this.handlePdfUpload(e));

        // Close modals on outside click
        ['saveModal', 'loadModal', 'exportModal', 'pdfPageModal'].forEach(id => {
          const modal = document.getElementById(id);
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              modal.classList.remove('active');
            }
          });
        });
      },

      togglePanel(panelName) {
        const panel = document.getElementById(panelName + 'Panel');
        const otherPanel = panelName === 'tools' ? document.getElementById('colorsPanel') : document.getElementById('toolsPanel');

        if (panel.classList.contains('show')) {
          panel.classList.remove('show');
        } else {
          otherPanel.classList.remove('show');
          panel.classList.add('show');
        }
      },

      closePanel(panelName) {
        document.getElementById(panelName + 'Panel').classList.remove('show');
      },

      renderColors() {
        const grid = document.getElementById('colorGrid');
        grid.innerHTML = '';
        this.colors.forEach(color => {
          const swatch = document.createElement('div');
          swatch.className = 'color-swatch';
          swatch.style.backgroundColor = color;
          if (color === this.currentColor) swatch.classList.add('active');
          swatch.addEventListener('click', () => {
            this.currentColor = color;
            document.getElementById('customColor').value = color;
            this.updateUI();
            this.renderColors();
          });
          grid.appendChild(swatch);
        });
      },

      updateUI() {
        document.getElementById('brushSizeLabel').textContent = this.brushSize;
        document.getElementById('toolStatus').textContent = this.currentTool;
        document.getElementById('historyInfo').textContent = `${this.historyIndex + 1} / ${this.history.length}`;

        const dot = document.getElementById('sizePreviewDot');
        dot.style.width = this.brushSize + 'px';
        dot.style.height = this.brushSize + 'px';
        dot.style.backgroundColor = this.currentColor;

        document.querySelectorAll('.tool-item').forEach(item => {
          item.classList.remove('active');
          if (item.dataset.tool === this.currentTool) {
            item.classList.add('active');
          }
        });
      },

      handleTouch(e, type) {
        // Handle pinch to zoom
        if (e.touches.length === 2) {
          e.preventDefault();
          this.isPinching = true;

          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const distance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
          );

          if (type === 'start') {
            this.pinchStartDistance = distance;
          } else if (type === 'move' && this.pinchStartDistance > 0) {
            const scale = distance / this.pinchStartDistance;
            const newZoom = Math.max(0.5, Math.min(3, this.zoomLevel * scale));

            if (Math.abs(newZoom - this.zoomLevel) > 0.01) {
              this.zoomLevel = newZoom;
              this.applyZoom();
              this.pinchStartDistance = distance;
            }
          }
          return;
        }

        // Normal drawing
        if (this.isPinching) {
          this.isPinching = false;
          this.pinchStartDistance = 0;
          return;
        }

        if (this.currentTool === 'pan') {
          // Pan tool doesn't draw, just allows scrolling/zooming
          return;
        }

        e.preventDefault();
        const touch = e.touches[0];
        if (touch) {
          const mouseEvent = new MouseEvent(
            type === 'start' ? 'mousedown' : 'mousemove',
            { clientX: touch.clientX, clientY: touch.clientY }
          );
          this.canvas.dispatchEvent(mouseEvent);
        }
      },

      getMousePos(e) {
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;

        return {
          x: (e.clientX - rect.left) * scaleX,
          y: (e.clientY - rect.top) * scaleY
        };
      },

      startDrawing(e) {
        this.isDrawing = true;
        const pos = this.getMousePos(e);
        this.startX = pos.x;
        this.startY = pos.y;

        if (this.currentTool === 'pen' || this.currentTool === 'brush') {
          this.ctx.beginPath();
          this.ctx.moveTo(pos.x, pos.y);
        } else if (this.currentTool === 'text') {
          this.drawText(pos.x, pos.y);
          this.isDrawing = false;
          this.saveState();
        }
      },

      draw(e) {
        if (!this.isDrawing) return;
        const pos = this.getMousePos(e);

        if (this.currentTool === 'pen' || this.currentTool === 'brush') {
          this.ctx.strokeStyle = this.currentColor;
          this.ctx.lineWidth = this.currentTool === 'brush' ? this.brushSize * 2 : this.brushSize;
          this.ctx.lineTo(pos.x, pos.y);
          this.ctx.stroke();
        } else if (this.currentTool === 'eraser') {
          this.ctx.clearRect(pos.x - this.brushSize, pos.y - this.brushSize, this.brushSize * 2, this.brushSize * 2);
        }
      },

      stopDrawing(e) {
        if (!this.isDrawing) return;

        if (e) {
          const pos = this.getMousePos(e);
          if (this.currentTool === 'line') this.drawLine(this.startX, this.startY, pos.x, pos.y);
          else if (this.currentTool === 'rectangle') this.drawRectangle(this.startX, this.startY, pos.x, pos.y);
          else if (this.currentTool === 'circle') this.drawCircle(this.startX, this.startY, pos.x, pos.y);
          else if (this.currentTool === 'arrow') this.drawArrow(this.startX, this.startY, pos.x, pos.y);
        }

        this.isDrawing = false;
        this.saveState();
      },

      drawLine(x1, y1, x2, y2) {
        this.ctx.strokeStyle = this.currentColor;
        this.ctx.lineWidth = this.brushSize;
        this.ctx.beginPath();
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);
        this.ctx.stroke();
      },

      drawRectangle(x1, y1, x2, y2) {
        this.ctx.strokeStyle = this.currentColor;
        this.ctx.lineWidth = this.brushSize;
        this.ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
      },

      drawCircle(x1, y1, x2, y2) {
        const radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        this.ctx.strokeStyle = this.currentColor;
        this.ctx.lineWidth = this.brushSize;
        this.ctx.beginPath();
        this.ctx.arc(x1, y1, radius, 0, 2 * Math.PI);
        this.ctx.stroke();
      },

      drawArrow(x1, y1, x2, y2) {
        const headlen = 15;
        const angle = Math.atan2(y2 - y1, x2 - x1);
        this.ctx.strokeStyle = this.currentColor;
        this.ctx.lineWidth = this.brushSize;

        this.ctx.beginPath();
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);
        this.ctx.stroke();

        this.ctx.beginPath();
        this.ctx.moveTo(x2, y2);
        this.ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y2 - headlen * Math.sin(angle - Math.PI / 6));
        this.ctx.moveTo(x2, y2);
        this.ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y2 - headlen * Math.sin(angle + Math.PI / 6));
        this.ctx.stroke();
      },

      drawText(x, y) {
        const text = prompt('Ø£Ø¯Ø®Ù„ Ø§Ù„Ù†Øµ:');
        if (text) {
          this.ctx.fillStyle = this.currentColor;
          this.ctx.font = (this.brushSize * 5) + 'px Arial';
          this.ctx.fillText(text, x, y);
        }
      },

      insertShape(shape) {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        const size = 50;

        this.ctx.fillStyle = this.currentColor;
        this.ctx.strokeStyle = this.currentColor;
        this.ctx.lineWidth = this.brushSize;

        switch(shape) {
          case 'star': this.drawStar(centerX, centerY, 5, size, size/2); break;
          case 'heart': this.drawHeart(centerX, centerY, size); break;
          case 'triangle': this.drawTriangle(centerX, centerY, size); break;
          case 'hexagon': this.drawPolygon(centerX, centerY, 6, size); break;
          case 'pentagon': this.drawPolygon(centerX, centerY, 5, size); break;
          case 'diamond': this.drawDiamond(centerX, centerY, size); break;
        }

        this.saveState();
      },

      drawStar(cx, cy, spikes, outerRadius, innerRadius) {
        let rot = Math.PI / 2 * 3;
        const step = Math.PI / spikes;
        this.ctx.beginPath();
        this.ctx.moveTo(cx, cy - outerRadius);

        for (let i = 0; i < spikes; i++) {
          let x = cx + Math.cos(rot) * outerRadius;
          let y = cy + Math.sin(rot) * outerRadius;
          this.ctx.lineTo(x, y);
          rot += step;
          x = cx + Math.cos(rot) * innerRadius;
          y = cy + Math.sin(rot) * innerRadius;
          this.ctx.lineTo(x, y);
          rot += step;
        }

        this.ctx.lineTo(cx, cy - outerRadius);
        this.ctx.closePath();
        this.ctx.stroke();
      },

      drawHeart(cx, cy, size) {
        this.ctx.beginPath();
        const topCurveHeight = size * 0.3;
        this.ctx.moveTo(cx, cy + topCurveHeight);
        this.ctx.bezierCurveTo(cx, cy, cx - size / 2, cy - size / 2, cx - size / 2, cy + topCurveHeight);
        this.ctx.bezierCurveTo(cx - size / 2, cy + (size + topCurveHeight) / 2, cx, cy + (size + topCurveHeight) / 2, cx, cy + size);
        this.ctx.bezierCurveTo(cx, cy + (size + topCurveHeight) / 2, cx + size / 2, cy + (size + topCurveHeight) / 2, cx + size / 2, cy + topCurveHeight);
        this.ctx.bezierCurveTo(cx + size / 2, cy - size / 2, cx, cy, cx, cy + topCurveHeight);
        this.ctx.closePath();
        this.ctx.stroke();
      },

      drawTriangle(cx, cy, size) {
        this.ctx.beginPath();
        this.ctx.moveTo(cx, cy - size);
        this.ctx.lineTo(cx - size, cy + size);
        this.ctx.lineTo(cx + size, cy + size);
        this.ctx.closePath();
        this.ctx.stroke();
      },

      drawPolygon(cx, cy, sides, size) {
        this.ctx.beginPath();
        for (let i = 0; i < sides; i++) {
          const angle = (i * 2 * Math.PI) / sides - Math.PI / 2;
          const x = cx + size * Math.cos(angle);
          const y = cy + size * Math.sin(angle);
          if (i === 0) this.ctx.moveTo(x, y);
          else this.ctx.lineTo(x, y);
        }
        this.ctx.closePath();
        this.ctx.stroke();
      },

      drawDiamond(cx, cy, size) {
        this.ctx.beginPath();
        this.ctx.moveTo(cx, cy - size);
        this.ctx.lineTo(cx + size, cy);
        this.ctx.lineTo(cx, cy + size);
        this.ctx.lineTo(cx - size, cy);
        this.ctx.closePath();
        this.ctx.stroke();
      },

      setTool(tool) {
        this.currentTool = tool;
        this.updateUI();
      },

      saveState() {
        this.history = this.history.slice(0, this.historyIndex + 1);
        this.history.push(this.canvas.toDataURL());
        this.historyIndex++;
        if (this.history.length > 50) {
          this.history.shift();
          this.historyIndex--;
        }
        this.updateUI();
      },

      restoreState(index) {
        const img = new Image();
        img.src = this.history[index];
        img.onload = () => {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.ctx.drawImage(img, 0, 0);
        };
      },

      undo() {
        if (this.historyIndex > 0) {
          this.historyIndex--;
          this.restoreState(this.historyIndex);
          this.updateUI();
        }
      },

      redo() {
        if (this.historyIndex < this.history.length - 1) {
          this.historyIndex++;
          this.restoreState(this.historyIndex);
          this.updateUI();
        }
      },

      clearCanvas() {
        if (confirm(this.t('clear_confirm'))) {
          this.ctx.fillStyle = 'white';
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          this.saveState();
        }
      },

      importImage() {
        document.getElementById('imageUpload').click();
      },

      handleImageUpload(e) {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
              this.ctx.drawImage(img, 0, 0);
              this.saveState();
            };
            img.src = event.target.result;
          };
          reader.readAsDataURL(file);
        }
      },

      openSaveModal() {
        document.getElementById('saveModal').classList.add('active');
      },

      closeSaveModal() {
        document.getElementById('saveModal').classList.remove('active');
        document.getElementById('saveName').value = '';
        document.getElementById('saveFolder').value = '';
      },

      openLoadModal() {
        document.getElementById('loadModal').classList.add('active');
        this.loadSavedFiles();
      },

      closeLoadModal() {
        document.getElementById('loadModal').classList.remove('active');
      },

      openExportModal() {
        document.getElementById('exportModal').classList.add('active');
      },

      closeExportModal() {
        document.getElementById('exportModal').classList.remove('active');
      },

      saveDrawing() {
        const name = document.getElementById('saveName').value.trim();
        const folder = document.getElementById('saveFolder').value.trim();

        if (!name) {
          alert(this.t('enter_name'));
          return;
        }

        const drawing = {
          id: Date.now(),
          name: name,
          folder: folder,
          data: this.canvas.toDataURL(),
          date: new Date().toLocaleDateString('ar-SA')
        };

        let drawings = JSON.parse(localStorage.getItem('drawings') || '[]');
        drawings.push(drawing);
        localStorage.setItem('drawings', JSON.stringify(drawings));

        this.lastSaved = drawing.date;
        this.closeSaveModal();
        alert(this.t('saved_success'));
      },

      loadSavedFiles() {
        const drawings = JSON.parse(localStorage.getItem('drawings') || '[]');
        const list = document.getElementById('filesList');

        if (drawings.length === 0) {
          list.innerHTML = '<div style="text-align: center; padding: 2rem; color: rgba(148, 163, 184, 0.8);">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø±Ø³ÙˆÙ…Ø§Øª Ù…Ø­ÙÙˆØ¸Ø©</div>';
          return;
        }

        list.innerHTML = '';
        drawings.reverse().forEach(drawing => {
          const item = document.createElement('div');
          item.className = 'file-item';
          item.innerHTML = `
            <div class="file-info">
              <div class="file-name">${drawing.name}</div>
              <div class="file-meta">${drawing.folder || 'Ø¨Ø¯ÙˆÙ† Ù…Ø¬Ù„Ø¯'} â€¢ ${drawing.date}</div>
            </div>
            <div class="file-actions">
              <button class="btn-small" onclick="app.deleteDrawing(${drawing.id}); event.stopPropagation();">ğŸ—‘ï¸</button>
            </div>
          `;
          item.addEventListener('click', () => this.loadDrawing(drawing.id));
          list.appendChild(item);
        });
      },

      loadDrawing(id) {
        const drawings = JSON.parse(localStorage.getItem('drawings') || '[]');
        const drawing = drawings.find(d => d.id === id);

        if (drawing) {
          const img = new Image();
          img.onload = () => {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.drawImage(img, 0, 0);
            this.saveState();
            this.closeLoadModal();
          };
          img.src = drawing.data;
        }
      },

      deleteDrawing(id) {
        if (confirm(this.t('delete_confirm'))) {
          let drawings = JSON.parse(localStorage.getItem('drawings') || '[]');
          drawings = drawings.filter(d => d.id !== id);
          localStorage.setItem('drawings', JSON.stringify(drawings));
          this.loadSavedFiles();
        }
      },

      exportAsPNG() {
        const link = document.createElement('a');
        const name = document.getElementById('saveName').value.trim() || 'drawing';
        link.download = name + '.png';
        link.href = this.canvas.toDataURL();
        link.click();
        this.closeExportModal();
      },

      exportAsJPG() {
        const link = document.createElement('a');
        const name = document.getElementById('saveName').value.trim() || 'drawing';
        link.download = name + '.jpg';
        link.href = this.canvas.toDataURL('image/jpeg');
        link.click();
        this.closeExportModal();
      },

      async exportAsPDF() {
        // If in PDF mode with multiple pages, show page selector
        if (this.pdfMode && this.pdfPages.length > 1) {
          this.closeExportModal();
          await this.showExportPagesSelector();
        } else {
          // Single page export
          await this.performPDFExport();
        }
      },

      async showExportPagesSelector() {
        const modal = document.getElementById('exportPagesModal');
        const selector = document.getElementById('exportPageSelector');
        selector.innerHTML = '';

        // Initialize selectedExportPages if not exists
        if (!this.selectedExportPages) {
          this.selectedExportPages = new Set();
        }
        this.selectedExportPages.clear();

        // Select all pages by default
        for (let i = 0; i < this.pdfPages.length; i++) {
          this.selectedExportPages.add(i);
        }

        // Create preview for each page
        for (let i = 0; i < this.pdfPages.length; i++) {
          const pageNum = this.pdfPages[i];
          const pageItem = document.createElement('div');
          pageItem.className = 'page-item selected';
          pageItem.dataset.pageIndex = i;
          pageItem.innerHTML = `
            <div style="width: 150px; height: 100px; background: #f0f0f0; display: flex; align-items: center; justify-content: center; border-radius: 8px;">
              <div style="font-size: 2rem;">ğŸ“„</div>
            </div>
            <div class="page-label">${this.t('page')} ${i + 1}</div>
          `;

          pageItem.addEventListener('click', () => {
            pageItem.classList.toggle('selected');
            if (pageItem.classList.contains('selected')) {
              this.selectedExportPages.add(i);
            } else {
              this.selectedExportPages.delete(i);
            }
          });

          selector.appendChild(pageItem);
        }

        modal.classList.add('active');
      },

      async confirmExportPages() {
        if (!this.selectedExportPages || this.selectedExportPages.size === 0) {
          alert(this.t('select_one_page') || 'Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ ØµÙØ­Ø© ÙˆØ§Ø­Ø¯Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„');
          return;
        }

        this.closeExportPagesModal();
        await this.performPDFExport();
      },

      async performPDFExport() {
        const { jsPDF } = window.jspdf;
        const name = document.getElementById('saveName').value.trim() || 'drawing';

        // If in PDF mode with multiple pages
        if (this.pdfMode && this.pdfPages.length > 0) {
          // Save current page annotations before export
          this.saveCurrentPageAnnotations();

          // Determine which pages to export
          const pagesToExport = this.selectedExportPages && this.selectedExportPages.size > 0
            ? Array.from(this.selectedExportPages).sort((a, b) => a - b)
            : this.pdfPages.map((_, i) => i);

          // Show loading with progress
          this.showLoading(this.currentLang === 'ar' ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØµØ¯ÙŠØ±...' : 'Exporting...');

          const pdf = new jsPDF({
            orientation: 'landscape',
            unit: 'px',
            format: [this.canvas.width, this.canvas.height]
          });

          const currentPageIndex = this.currentPageIndex;

          // Add selected pages with annotations
          for (let i = 0; i < pagesToExport.length; i++) {
            const pageIndex = pagesToExport[i];
            const pageNum = this.pdfPages[pageIndex];

            // Update progress
            this.updateLoadingProgress(i + 1, pagesToExport.length);

            if (i > 0) {
              pdf.addPage([this.canvas.width, this.canvas.height], 'landscape');
            }

            // Use saved annotations if available, otherwise load fresh
            if (this.pageAnnotations[pageNum]) {
              // Use the saved annotated version
              await new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                  this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                  this.ctx.drawImage(img, 0, 0);
                  pdf.addImage(this.canvas.toDataURL(), 'PNG', 0, 0, this.canvas.width, this.canvas.height);
                  resolve();
                };
                img.src = this.pageAnnotations[pageNum];
              });
            } else {
              // Load the page without annotations
              await this.loadPdfPage(pageNum, false);
              pdf.addImage(this.canvas.toDataURL(), 'PNG', 0, 0, this.canvas.width, this.canvas.height);
            }
          }

          // Restore current page view
          this.currentPageIndex = currentPageIndex;
          await this.loadPdfPage(this.pdfPages[this.currentPageIndex]);

          this.hideLoading();
          pdf.save(name + '_annotated.pdf');
        } else {
          // Single page export
          this.showLoading(this.currentLang === 'ar' ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØµØ¯ÙŠØ±...' : 'Exporting...');

          const pdf = new jsPDF({
            orientation: 'landscape',
            unit: 'px',
            format: [this.canvas.width, this.canvas.height]
          });

          pdf.addImage(this.canvas.toDataURL(), 'PNG', 0, 0, this.canvas.width, this.canvas.height);

          this.hideLoading();
          pdf.save(name + '.pdf');
        }

        this.closeExportModal();
      },

      // PDF Import Functions
      async handlePdfUpload(e) {
        const file = e.target.files[0];
        if (!file) return;

        try {
          const arrayBuffer = await file.arrayBuffer();
          this.pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

          // Show page selector modal
          await this.showPdfPageSelector();
        } catch (error) {
          alert(this.t('pdf_load_error') + ': ' + error.message);
        }

        // Reset file input
        e.target.value = '';
      },

      async showPdfPageSelector() {
        this.showLoading(this.t('loading_pages'));

        const modal = document.getElementById('pdfPageModal');
        const selector = document.getElementById('pdfPageSelector');
        selector.innerHTML = '';
        this.selectedPdfPages.clear();

        const numPages = this.pdfDoc.numPages;

        // Select all pages by default
        for (let i = 1; i <= numPages; i++) {
          this.selectedPdfPages.add(i);
        }

        // Limit preview to first 50 pages for performance
        const previewLimit = Math.min(numPages, 50);

        for (let i = 1; i <= previewLimit; i++) {
          this.updateLoadingProgress(i, previewLimit);

          const page = await this.pdfDoc.getPage(i);
          const viewport = page.getViewport({ scale: 0.3 });

          const canvas = document.createElement('canvas');
          canvas.className = 'page-preview';
          canvas.width = viewport.width;
          canvas.height = viewport.height;

          const ctx = canvas.getContext('2d');
          await page.render({ canvasContext: ctx, viewport: viewport }).promise;

          const pageItem = document.createElement('div');
          pageItem.className = 'page-item selected';
          pageItem.dataset.pageNum = i;
          pageItem.innerHTML = `
            ${canvas.outerHTML}
            <div class="page-label">${this.t('page')} ${i}</div>
          `;

          pageItem.addEventListener('click', () => {
            pageItem.classList.toggle('selected');
            if (pageItem.classList.contains('selected')) {
              this.selectedPdfPages.add(i);
            } else {
              this.selectedPdfPages.delete(i);
            }
          });

          selector.appendChild(pageItem);
        }

        // If there are more pages, show a message
        if (numPages > previewLimit) {
          const messageEl = document.createElement('div');
          messageEl.style.cssText = 'grid-column: 1 / -1; text-align: center; padding: 20px; color: #f8fafc;';
          messageEl.textContent = `${this.t('loading_pages')}... (${previewLimit}/${numPages}). ${this.t('page_range_help')}`;
          selector.appendChild(messageEl);
        }

        this.hideLoading();
        modal.classList.add('active');

        // Set page range input to "all"
        document.getElementById('pageRangeInput').value = numPages <= 50 ? '' : this.currentLang === 'ar' ? 'Ø§Ù„ÙƒÙ„' : 'all';
      },

      async importSelectedPages() {
        if (this.selectedPdfPages.size === 0) {
          alert(this.t('select_one_page'));
          return;
        }

        // Convert selected pages to sorted array
        this.pdfPages = Array.from(this.selectedPdfPages).sort((a, b) => a - b);
        this.currentPageIndex = 0;
        this.pdfMode = true;

        // Load first page
        await this.loadPdfPage(this.pdfPages[0]);

        // Show PDF navigation
        document.getElementById('pdfNavigation').classList.add('active');
        this.updatePdfNavigation();

        this.closePdfModal();
      },

      async loadPdfPage(pageNum, restoreAnnotations = true) {
        try {
          const page = await this.pdfDoc.getPage(pageNum);

          // Calculate scale to fit canvas
          const viewport = page.getViewport({ scale: 1 });
          const scaleX = this.canvas.width / viewport.width;
          const scaleY = this.canvas.height / viewport.height;
          const scale = Math.min(scaleX, scaleY) * 0.9; // 90% of canvas size

          const scaledViewport = page.getViewport({ scale: scale });

          // Create temporary canvas for PDF rendering
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = scaledViewport.width;
          tempCanvas.height = scaledViewport.height;
          const tempCtx = tempCanvas.getContext('2d');

          // Render PDF page
          await page.render({
            canvasContext: tempCtx,
            viewport: scaledViewport
          }).promise;

          // Clear main canvas and draw PDF page centered
          this.ctx.fillStyle = 'white';
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          const x = (this.canvas.width - scaledViewport.width) / 2;
          const y = (this.canvas.height - scaledViewport.height) / 2;
          this.ctx.drawImage(tempCanvas, x, y);

          // Restore annotations if available
          if (restoreAnnotations && this.pageAnnotations[pageNum]) {
            const img = new Image();
            img.onload = () => {
              this.ctx.drawImage(img, 0, 0);
              this.saveState();
            };
            img.src = this.pageAnnotations[pageNum];
          } else {
            // Save to history
            this.saveState();
          }
        } catch (error) {
          alert(this.t('page_load_error') + ': ' + error.message);
        }
      },

      saveCurrentPageAnnotations() {
        if (this.pdfMode && this.pdfPages.length > 0) {
          const currentPage = this.pdfPages[this.currentPageIndex];
          this.pageAnnotations[currentPage] = this.canvas.toDataURL();
        }
      },

      previousPage() {
        if (this.currentPageIndex > 0) {
          // Save current page annotations
          this.saveCurrentPageAnnotations();

          this.currentPageIndex--;
          this.loadPdfPage(this.pdfPages[this.currentPageIndex]);
          this.updatePdfNavigation();

          // Save last position
          this.saveLastPdfPosition();
        }
      },

      nextPage() {
        if (this.currentPageIndex < this.pdfPages.length - 1) {
          // Save current page annotations
          this.saveCurrentPageAnnotations();

          this.currentPageIndex++;
          this.loadPdfPage(this.pdfPages[this.currentPageIndex]);
          this.updatePdfNavigation();

          // Save last position
          this.saveLastPdfPosition();
        }
      },

      updatePdfNavigation() {
        const pageInfo = document.getElementById('pageInfo');
        const prevBtn = document.getElementById('prevPageBtn');
        const nextBtn = document.getElementById('nextPageBtn');

        pageInfo.textContent = `${this.t('page')} ${this.currentPageIndex + 1} ${this.t('of')} ${this.pdfPages.length}`;
        prevBtn.disabled = this.currentPageIndex === 0;
        nextBtn.disabled = this.currentPageIndex === this.pdfPages.length - 1;
      },

      closePdfModal() {
        document.getElementById('pdfPageModal').classList.remove('active');
      },

      // Language Management
      switchLanguage(lang) {
        this.currentLang = lang;
        localStorage.setItem('drawing_lang', lang);
        this.applyLanguage();

        // Update HTML attributes
        document.documentElement.lang = lang;
        document.documentElement.dir = lang === 'ar' ? 'rtl' : 'ltr';

        // Update active button
        document.querySelectorAll('.lang-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.lang === lang);
        });
      },

      applyLanguage() {
        const translations = this.translations[this.currentLang];

        // Update all elements with data-i18n attribute
        document.querySelectorAll('[data-i18n]').forEach(element => {
          const key = element.getAttribute('data-i18n');
          if (translations[key]) {
            element.textContent = translations[key];
          }
        });

        // Update title
        document.title = this.currentLang === 'ar'
          ? 'Ù„ÙˆØ­Ø© Ø§Ù„Ø±Ø³Ù… â€” Mishkah Drawing Board'
          : 'Mishkah Drawing Board';
      },

      t(key) {
        return this.translations[this.currentLang][key] || key;
      },

      // PWA Install Functions
      async installApp() {
        if (!this.deferredPrompt) {
          console.log('Install prompt not available');
          return;
        }

        // Show the install prompt
        this.deferredPrompt.prompt();

        // Wait for the user to respond
        const { outcome } = await this.deferredPrompt.userChoice;
        console.log(`User response: ${outcome}`);

        // Clear the deferred prompt
        this.deferredPrompt = null;

        // Hide the install prompt
        document.getElementById('installPrompt').classList.remove('active');
      },

      dismissInstall() {
        document.getElementById('installPrompt').classList.remove('active');
        localStorage.setItem('install_dismissed', 'true');
      },

      // Hard Reload - Clear cache and force update
      async hardReload() {
        try {
          // Show loading indicator
          this.showLoading(this.currentLang === 'ar' ? 'Ø¬Ø§Ø±ÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØ·Ø¨ÙŠÙ‚...' : 'Updating app...');

          // Unregister all service workers
          if ('serviceWorker' in navigator) {
            const registrations = await navigator.serviceWorker.getRegistrations();
            for (let registration of registrations) {
              await registration.unregister();
              console.log('Service worker unregistered');
            }
          }

          // Clear all caches
          if ('caches' in window) {
            const cacheNames = await caches.keys();
            for (let cacheName of cacheNames) {
              await caches.delete(cacheName);
              console.log(`Cache ${cacheName} deleted`);
            }
          }

          // Clear localStorage except language preference
          const lang = localStorage.getItem('drawing_lang');
          localStorage.clear();
          if (lang) {
            localStorage.setItem('drawing_lang', lang);
          }

          // Force reload with cache bypass
          setTimeout(() => {
            window.location.reload(true);
          }, 500);
        } catch (error) {
          console.error('Hard reload error:', error);
          // Force reload anyway
          window.location.reload(true);
        }
      },

      // Zoom Functions
      zoomIn() {
        this.zoomLevel = Math.min(3, this.zoomLevel + 0.1);
        this.applyZoom();
      },

      zoomOut() {
        this.zoomLevel = Math.max(0.5, this.zoomLevel - 0.1);
        this.applyZoom();
      },

      resetZoom() {
        this.zoomLevel = 1;
        this.applyZoom();
      },

      applyZoom() {
        // Remove transform and use direct sizing for better scroll support
        // Set canvas visual size based on zoom level
        const baseWidth = window.innerWidth;
        const baseHeight = window.innerHeight;

        this.canvas.style.width = `${baseWidth * this.zoomLevel}px`;
        this.canvas.style.height = `${baseHeight * this.zoomLevel}px`;
        this.canvas.style.transform = 'none';

        // Update zoom level display
        document.getElementById('zoomLevel').textContent = Math.round(this.zoomLevel * 100) + '%';
      },

      // Zen Mode
      toggleZenMode() {
        this.zenMode = !this.zenMode;
        document.body.classList.toggle('zen-mode', this.zenMode);
      },

      // Loading Functions
      showLoading(text = null) {
        const overlay = document.getElementById('loadingOverlay');
        const progressEl = document.getElementById('loadingProgress');
        overlay.classList.add('active');
        if (text) {
          progressEl.textContent = text;
        }
      },

      hideLoading() {
        document.getElementById('loadingOverlay').classList.remove('active');
      },

      updateLoadingProgress(current, total) {
        const progressEl = document.getElementById('loadingProgress');
        progressEl.textContent = this.t('page_x_of_y').replace('{0}', current).replace('{1}', total);
      },

      // Smart Page Selector Functions
      selectAllPages() {
        if (!this.pdfDoc) return;

        this.selectedPdfPages.clear();
        for (let i = 1; i <= this.pdfDoc.numPages; i++) {
          this.selectedPdfPages.add(i);
        }

        // Update UI
        document.querySelectorAll('.page-item').forEach(item => {
          item.classList.add('selected');
        });
      },

      deselectAllPages() {
        this.selectedPdfPages.clear();

        // Update UI
        document.querySelectorAll('.page-item').forEach(item => {
          item.classList.remove('selected');
        });
      },

      applyPageRange() {
        const input = document.getElementById('pageRangeInput').value.trim();
        if (!input || !this.pdfDoc) return;

        const pages = this.parsePageRange(input, this.pdfDoc.numPages);
        if (pages.length === 0) {
          alert(this.t('select_one_page'));
          return;
        }

        this.selectedPdfPages.clear();
        pages.forEach(page => this.selectedPdfPages.add(page));

        // Update UI
        document.querySelectorAll('.page-item').forEach(item => {
          const pageNum = parseInt(item.dataset.pageNum);
          item.classList.toggle('selected', this.selectedPdfPages.has(pageNum));
        });
      },

      parsePageRange(input, maxPages) {
        const pages = new Set();

        // Handle "all" or "Ø§Ù„ÙƒÙ„"
        if (input.toLowerCase() === 'all' || input === 'Ø§Ù„ÙƒÙ„') {
          for (let i = 1; i <= maxPages; i++) {
            pages.add(i);
          }
          return Array.from(pages).sort((a, b) => a - b);
        }

        const parts = input.split(',');

        for (let part of parts) {
          part = part.trim();

          // Handle range (e.g., "1-10")
          if (part.includes('-')) {
            const [start, end] = part.split('-').map(n => parseInt(n.trim()));
            if (!isNaN(start) && !isNaN(end)) {
              for (let i = Math.min(start, end); i <= Math.max(start, end); i++) {
                if (i >= 1 && i <= maxPages) {
                  pages.add(i);
                }
              }
            }
          } else {
            // Handle single page
            const page = parseInt(part);
            if (!isNaN(page) && page >= 1 && page <= maxPages) {
              pages.add(page);
            }
          }
        }

        return Array.from(pages).sort((a, b) => a - b);
      },

      async previewRange() {
        const input = document.getElementById('pageRangeInput').value.trim();
        if (!input || !this.pdfDoc) return;

        const pages = this.parsePageRange(input, this.pdfDoc.numPages);
        if (pages.length === 0) {
          alert(this.t('select_one_page'));
          return;
        }

        // Show only selected pages in preview
        this.showLoading(this.t('loading_pages'));

        const selector = document.getElementById('pdfPageSelector');
        selector.innerHTML = '';

        for (let pageNum of pages) {
          const page = await this.pdfDoc.getPage(pageNum);
          const viewport = page.getViewport({ scale: 0.3 });

          const canvas = document.createElement('canvas');
          canvas.className = 'page-preview';
          canvas.width = viewport.width;
          canvas.height = viewport.height;

          const ctx = canvas.getContext('2d');
          await page.render({ canvasContext: ctx, viewport: viewport }).promise;

          const pageItem = document.createElement('div');
          pageItem.className = 'page-item selected';
          pageItem.dataset.pageNum = pageNum;
          pageItem.innerHTML = `
            ${canvas.outerHTML}
            <div class="page-label">${this.t('page')} ${pageNum}</div>
          `;

          pageItem.addEventListener('click', () => {
            pageItem.classList.toggle('selected');
            if (pageItem.classList.contains('selected')) {
              this.selectedPdfPages.add(pageNum);
            } else {
              this.selectedPdfPages.delete(pageNum);
            }
          });

          selector.appendChild(pageItem);
          this.selectedPdfPages.add(pageNum);
        }

        this.hideLoading();
      },

      // Export Pages Modal Functions
      closeExportPagesModal() {
        document.getElementById('exportPagesModal').classList.remove('active');
      },

      selectAllExportPages() {
        if (!this.selectedExportPages) {
          this.selectedExportPages = new Set();
        }
        this.selectedExportPages.clear();

        for (let i = 0; i < this.pdfPages.length; i++) {
          this.selectedExportPages.add(i);
        }

        // Update UI
        document.querySelectorAll('#exportPageSelector .page-item').forEach(item => {
          item.classList.add('selected');
        });
      },

      deselectAllExportPages() {
        if (!this.selectedExportPages) {
          this.selectedExportPages = new Set();
        }
        this.selectedExportPages.clear();

        // Update UI
        document.querySelectorAll('#exportPageSelector .page-item').forEach(item => {
          item.classList.remove('selected');
        });
      },

      applyExportPageRange() {
        const input = document.getElementById('exportPageRangeInput').value.trim();
        if (!input) return;

        const pages = this.parseExportPageRange(input, this.pdfPages.length);
        if (pages.length === 0) {
          alert(this.t('select_one_page') || 'Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ ØµÙØ­Ø© ÙˆØ§Ø­Ø¯Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„');
          return;
        }

        if (!this.selectedExportPages) {
          this.selectedExportPages = new Set();
        }
        this.selectedExportPages.clear();
        pages.forEach(page => this.selectedExportPages.add(page));

        // Update UI
        document.querySelectorAll('#exportPageSelector .page-item').forEach(item => {
          const pageIndex = parseInt(item.dataset.pageIndex);
          item.classList.toggle('selected', this.selectedExportPages.has(pageIndex));
        });
      },

      parseExportPageRange(input, maxPages) {
        const pages = new Set();

        // Handle "all" or "Ø§Ù„ÙƒÙ„"
        if (input.toLowerCase() === 'all' || input === 'Ø§Ù„ÙƒÙ„') {
          for (let i = 0; i < maxPages; i++) {
            pages.add(i);
          }
          return Array.from(pages).sort((a, b) => a - b);
        }

        const parts = input.split(',');

        for (let part of parts) {
          part = part.trim();

          // Handle range (e.g., "1-10")
          if (part.includes('-')) {
            const [start, end] = part.split('-').map(n => parseInt(n.trim()));
            if (!isNaN(start) && !isNaN(end)) {
              // Convert from 1-based to 0-based indexing
              for (let i = Math.min(start, end) - 1; i < Math.max(start, end); i++) {
                if (i >= 0 && i < maxPages) {
                  pages.add(i);
                }
              }
            }
          } else {
            // Handle single page (convert from 1-based to 0-based)
            const page = parseInt(part) - 1;
            if (!isNaN(page) && page >= 0 && page < maxPages) {
              pages.add(page);
            }
          }
        }

        return Array.from(pages).sort((a, b) => a - b);
      },

      // Save last PDF position
      saveLastPdfPosition() {
        if (this.pdfMode && this.pdfPages.length > 0) {
          localStorage.setItem('lastPdfPage', this.currentPageIndex);
          localStorage.setItem('lastPdfPages', JSON.stringify(this.pdfPages));
        }
      },

      loadLastPdfPosition() {
        const lastPage = localStorage.getItem('lastPdfPage');
        const lastPages = localStorage.getItem('lastPdfPages');

        if (lastPage && lastPages) {
          this.currentPageIndex = parseInt(lastPage);
          return JSON.parse(lastPages);
        }
        return null;
      }
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => app.init());
    } else {
      app.init();
    }
  </script>
</body>
</html>
